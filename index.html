<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Air Defense — Радарная игра</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<style>
  :root{--accent:#24d16a;--bg:#071021}
  html,body{height:100%;margin:0;font-family:Inter,Arial;background:var(--bg);color:#eaf6ff}
  #app{display:flex;height:100vh}
  #map{flex:1;position:relative}
  #hud{width:380px;background:rgba(6,8,12,0.8);padding:12px;box-sizing:border-box}
  .title{font-weight:800;font-size:18px;margin-bottom:6px}
  button{background:var(--accent);border:none;padding:8px 10px;border-radius:6px;color:#032014;font-weight:700;cursor:pointer}
  .controls{display:flex;gap:6px;margin-bottom:8px}
  .stat{margin:6px 0;padding:8px;background:rgba(255,255,255,0.03);border-radius:6px}
  .log{height:160px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-size:13px}
  .small{font-size:13px;opacity:0.9}
  canvas#overlay{position:absolute;left:0;top:0;pointer-events:none}
  .legend{margin-top:8px;font-size:13px}
</style>
</head>
<body>
<div id="app">
  <div id="map">
    <div id="mapid" style="width:100%;height:100%"></div>
    <canvas id="overlay"></canvas>
  </div>
  <div id="hud">
    <div class="title">Air Defense — Радар & ПВО</div>
    <div class="controls">
      <button id="startBtn">Старт</button>
      <button id="pauseBtn">Пауза</button>
      <button id="spawnShahed">Спавн Shahed</button>
    </div>

    <div class="stat">Очки: <strong id="score">0</strong> &nbsp; Жизни: <strong id="lives">5</strong></div>

    <div style="margin-top:8px;font-weight:700">Установленные элементы</div>
    <div class="small">Клик на карте — разместить РЛС. Shift+клик — установить батарею ПВО.</div>
    <div class="stat">РЛС: <span id="radarCount">0</span> &nbsp; Батарей: <span id="batteryCount">0</span></div>

    <div style="margin-top:8px;font-weight:700">Апгрейды / команды</div>
    <div class="small" style="margin-bottom:6px">Очки тратятся на улучшения:</div>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button id="upgradeDetection">+Обнаружение (100)</button>
      <button id="upgradeIntercept">+Срочность (150)</button>
      <button id="buyBattery">Купить батарею (200)</button>
    </div>

    <div style="margin-top:10px;font-weight:700">Логи</div>
    <div class="log" id="log"></div>

    <div class="legend">
      <div>Типы целей: <span style="color:#ffd54f">Shahed (низкий)</span>, <span style="color:#ffa500">Крылатая ракета</span>, <span style="color:#7fc1ff">Баллическая ракета</span>, <span style="color:#ff6b6b">Аэробаллистическая</span></div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/*
  Air Defense — расширенная версия: разные типы целей, РЛС с вероятностью обнаружения,
  батареи ПВО, расчёт перехвата, предсказания траекторий, апгрейды.
  ---
  Это обучающая/игровая симуляция. Не содержит инструкций по созданию оружия.
*/

const CITY = {name:'City', lat:50.45, lng:30.523};
const START_LIVES = 5;

// Map init
const map = L.map('mapid', {zoomControl:true}).setView([CITY.lat, CITY.lng], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19, attribution:''}).addTo(map);

// overlay canvas
const canvas = document.getElementById('overlay'); const ctx = canvas.getContext('2d');
function resize(){ const r = map.getContainer().getBoundingClientRect(); canvas.width = r.width; canvas.height = r.height; canvas.style.width = r.width+'px'; canvas.style.height = r.height+'px'; }
window.addEventListener('resize', resize); resize();
map.on('move', ()=>{ draw(); });

// Game state
let playing=false, paused=false; let score=0, lives=START_LIVES; let enemies=[], radars=[], batteries=[], projectiles=[], explosions=[]; let detectionBonus=1.0, interceptBonus=1.0;
let logEl = document.getElementById('log');

function addLog(s){ const d = new Date().toLocaleTimeString(); const el = document.createElement('div'); el.textContent = `[${d}] ${s}`; logEl.prepend(el); }
addLog('Система онлайн');

// Helpers: distances
function toRad(v){return v*Math.PI/180}
function hav(lat1,lon1,lat2,lon2){ const R=6371000; const dLat=toRad(lat2-lat1); const dLon=toRad(lon2-lon1); const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2; return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); }
function worldToScreen(lat,lng){ const p = map.latLngToContainerPoint([lat,lng]); return {x:p.x,y:p.y}; }
function rand(a,b){return Math.random()*(b-a)+a}

// Target types flight models
// Each enemy: {id,type,lat,lng,alt,mass,speed,dir,stage, hp, rcs}
let enemyId=1;
function spawn(type){
  const bounds = map.getBounds();
  const side = Math.floor(Math.random()*4);
  let lat,lng;
  const pad = 0.5;
  if (side===0){ lat = bounds.getSouth()-pad; lng = rand(bounds.getWest(), bounds.getEast()); }
  if (side===1){ lat = bounds.getNorth()+pad; lng = rand(bounds.getWest(), bounds.getEast()); }
  if (side===2){ lat = rand(bounds.getSouth(), bounds.getNorth()); lng = bounds.getWest()-pad; }
  if (side===3){ lat = rand(bounds.getSouth(), bounds.getNorth()); lng = bounds.getEast()+pad; }

  const types = {
    'shahed': {alt:300, speed:60, hp:1, rcs:0.6, color:'#ffd54f'}, // low slow
    'cruise': {alt:800, speed:220, hp:1, rcs:0.9, color:'#ffa500'},
    'ballistic': {alt:80000, speed:2500, hp:2, rcs:1.2, color:'#7fc1ff'},
    'aeroballistic': {alt:30000, speed:1200, hp:2, rcs:1.1, color:'#ff6b6b'}
  };
  const p = types[type] || types['shahed'];
  const id = enemyId++;
  const dirToCity = Math.atan2(CITY.lat - lat, CITY.lng - lng);
  enemies.push({id,type,lat,lng,alt:p.alt, speed:p.speed, dir:dirToCity, hp:p.hp, rcs:p.rcs, color:p.color, trail:[], stage:0});
  addLog('Появился ' + type);
}

// Radar detection model: each radar has lat,lng, rangeMeters, quality (multiplier)
function createRadar(lat,lng){ return {lat,lng,range:100000, quality:1.0}; }

// Battery: lat,lng, rangeMeters, reload (seconds), cooldown, interceptorSpeed, name
function createBattery(lat,lng){ return {lat,lng,range:90000, reload:6, cooldown:0, interceptorSpeed:1200, name:'Battery'}; }

// place default radar near city
radars.push(Object.assign({name:'Main Radar'}, createRadar(CITY.lat+0.02, CITY.lng-0.02)));
batteries.push(Object.assign({name:'Central SAM'}, createBattery(CITY.lat, CITY.lng+0.02)));

// Detection: each enemy may be 'detected' and 'tracked'. We will keep tracked list with lastSeen.
function detectEnemies(){
  for (const e of enemies){ e.detected = false; }
  for (const r of radars){
    for (const e of enemies){
      const d = hav(e.lat,e.lng, r.lat,r.lng);
      // detection probability depends on altitude and RCS and radar quality
      // low altitude harder to detect: we model as sigmoid
      const altFactor = 1 - Math.exp(-e.alt/8000); // higher -> easier
      const rcsFactor = Math.min(2, e.rcs);
      const baseProb = (1 - d / r.range) * 0.9 * r.quality * altFactor * rcsFactor * detectionBonus;
      const prob = Math.max(0, Math.min(1, baseProb));
      if (d < r.range && Math.random() < prob){ e.detected = true; e.lastSeen = Date.now(); e.detectedBy = r; }
    }
  }
}

// Intercept logic: find tracked targets within battery range and launch interceptor
function autoEngage(){
  for (const b of batteries){
    if (b.cooldown > 0){ b.cooldown -= 0.1; if (b.cooldown < 0) b.cooldown=0; continue; }
    // find detected enemy closest to city within range and within intercept geometry
    let best = null; let bestDist=1e12;
    for (const e of enemies){ if (!e.detected) continue; const d = hav(e.lat,e.lng, b.lat,b.lng); if (d < b.range){ const dc = hav(e.lat,e.lng, CITY.lat, CITY.lng); if (dc < bestDist){ bestDist = dc; best = e; } } }
    if (best){
      // compute simple intercept chance based on interceptor speed, target speed, alt and interceptBonus
      const relativeSpeed = Math.abs(best.speed - b.interceptorSpeed);
      const timeToIntercept = Math.max(0.5, bestDist / (b.interceptorSpeed*1000/3600));
      const baseChance = Math.min(0.95, (b.interceptorSpeed/ (best.speed+200)) * 0.5 + 0.25);
      const chance = Math.max(0.05, Math.min(0.99, baseChance * interceptBonus));
      projectiles.push({type:'interceptor', fromLat:b.lat, fromLng:b.lng, targetId:best.id, progress:0, timeToHit:timeToIntercept, start:Date.now(), chance});
      b.cooldown = b.reload;
      addLog(b.name + ' пускает перехватчик по ' + best.type);
    }
  }
}

// Update loop
let last = performance.now();
function update(){
  const now = performance.now(); const dt = (now-last)/1000; last = now;
  if (!playing || paused){ requestAnimationFrame(update); draw(); return; }

  // spawn random events
  if (Math.random() < 0.008){ // occasional spawn
    const r = Math.random(); if (r<0.5) spawn('shahed'); else if (r<0.75) spawn('cruise'); else if (r<0.9) spawn('ballistic'); else spawn('aeroballistic');
  }

  // move enemies according to simplified models
  for (let i=enemies.length-1;i>=0;i--){ const e=enemies[i];
    if (e.type==='shahed'){
      // low, slow constant heading to city
      const ang = Math.atan2(CITY.lat - e.lat, CITY.lng - e.lng);
      const kmPerSec = e.speed/3600; // km/s
      const degLat = kmPerSec * dt / 111; // approx degrees per km
      e.lat += Math.sin(ang) * degLat; e.lng += Math.cos(ang) * degLat;
    } else if (e.type==='cruise'){
      // cruise missiles follow low-altitude but faster and may zigzag
      const ang = Math.atan2(CITY.lat - e.lat, CITY.lng - e.lng) + Math.sin(Date.now()/500 + e.id)*0.02;
      const kmPerSec = e.speed/3600; const deg = kmPerSec * dt / 111;
      e.lat += Math.sin(ang) * deg; e.lng += Math.cos(ang) * deg;
    } else if (e.type==='ballistic'){
      // ballistic: high altitude, long glide, then terminal fast descent
      // we model as stage: stage 0 approach, stage 1 reentry/terminal
      if (e.stage===0){ e.alt -= 200*dt; if (e.alt < 20000) e.stage=1; const ang=Math.atan2(CITY.lat - e.lat, CITY.lng - e.lng); const kmPerSec = 400/3600; const deg = kmPerSec*dt/111; e.lat += Math.sin(ang)*deg; e.lng += Math.cos(ang)*deg; }
      else { // terminal: very fast
        const ang = Math.atan2(CITY.lat - e.lat, CITY.lng - e.lng); const kmPerSec = 1500/3600; const deg = kmPerSec*dt/111; e.lat += Math.sin(ang)*deg*3; e.lng += Math.cos(ang)*deg*3; e.alt -= 800*dt; }
    } else if (e.type==='aeroballistic'){
      // aeroballistic: midcourse maneuvers, then ballistic
      if (e.stage===0){ // midcourse
        e.alt -= 300*dt; const ang = Math.atan2(CITY.lat - e.lat, CITY.lng - e.lng) + Math.sin(Date.now()/800 + e.id)*0.4; const kmPerSec = e.speed/3600; const deg = kmPerSec*dt/111; e.lat += Math.sin(ang)*deg; e.lng += Math.cos(ang)*deg; if (e.alt < 15000) e.stage=1; }
      else { const ang=Math.atan2(CITY.lat - e.lat, CITY.lng - e.lng); const kmPerSec = 800/3600; const deg = kmPerSec*dt/111; e.lat += Math.sin(ang)*deg*2; e.lng += Math.cos(ang)*deg*2; e.alt -= 500*dt; }
    }
    e.trail.push({lat:e.lat,lng:e.lng}); if (e.trail.length>20) e.trail.shift();
    // impact check
    const dToCity = hav(e.lat,e.lng, CITY.lat, CITY.lng);
    if (dToCity < 3000 || e.alt < 100){ // hit
      enemies.splice(i,1); lives--; addLog(e.type + ' поразил цель — утеряна жизнь'); if (lives<=0){ playing=false; addLog('Город разрушен — игра окончена'); }
      explosions.push({lat:CITY.lat,lng:CITY.lng,life:0,max:50,size:120}); document.getElementById('lives').textContent = lives; continue; }
  }

  // detection
  detectEnemies();
  // auto-engage
  autoEngage();

  // projectiles progress
  for (let i=projectiles.length-1;i>=0;i--){ const p=projectiles[i];
    p.progress += dt/p.timeToHit;
    if (p.progress >= 1){
      // find target
      const target = enemies.find(x=>x.id===p.targetId);
      const hit = Math.random() < p.chance;
      if (target){ if (hit){ addLog('Перехват успешен по ' + target.type); score += 25; document.getElementById('score').textContent = score; // destroy target
            // explosion and remove
            explosions.push({lat:target.lat, lng:target.lng, life:0, max:40, size:60}); enemies = enemies.filter(x=>x.id!==target.id);
        } else { addLog('Перехват неудачен по id ' + p.targetId); }
      } else { addLog('Перехват столкнулся с пустотой'); }
      projectiles.splice(i,1);
    }
  }

  // explosion life
  for (let i=explosions.length-1;i>=0;i--){ const ex=explosions[i]; ex.life++; if (ex.life>ex.max) explosions.splice(i,1); }

  requestAnimationFrame(update); draw();
}

// draw
function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw trails and predicted paths
  for (const e of enemies){
    // trail
    ctx.beginPath(); for (let i=0;i<e.trail.length;i++){ const s = worldToScreen(e.trail[i].lat, e.trail[i].lng); if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);} ctx.strokeStyle = e.color + '55'; ctx.lineWidth = 2; ctx.stroke();
    // predicted line to city
    const cur = worldToScreen(e.lat,e.lng); const city = worldToScreen(CITY.lat,CITY.lng);
    ctx.beginPath(); ctx.moveTo(cur.x,cur.y); ctx.lineTo(city.x,city.y); ctx.strokeStyle = 'rgba(36,209,106,0.12)'; ctx.lineWidth = 6; ctx.stroke(); ctx.beginPath(); ctx.moveTo(cur.x,cur.y); ctx.lineTo(city.x,city.y); ctx.strokeStyle = 'rgba(36,209,106,0.5)'; ctx.lineWidth = 1; ctx.stroke();
    // icon
    ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(cur.x,cur.y,8,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.font='11px Arial'; ctx.fillText(e.hp, cur.x-4, cur.y+4);

    // if detected, draw marker
    if (e.detected) { ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(cur.x,cur.y,14,0,Math.PI*2); ctx.stroke(); }
  }

  // draw radars
  for (const r of radars){ const s = worldToScreen(r.lat,r.lng); const latOff = metersToLat(r.range); const edge = worldToScreen(r.lat+latOff, r.lng); const rr = Math.hypot(edge.x-s.x, edge.y-s.y);
    ctx.beginPath(); ctx.arc(s.x,s.y, rr,0,Math.PI*2); ctx.strokeStyle='rgba(70,130,180,0.08)'; ctx.lineWidth=12; ctx.stroke(); ctx.beginPath(); ctx.arc(s.x,s.y, rr,0,Math.PI*2); ctx.strokeStyle='rgba(70,130,180,0.5)'; ctx.lineWidth=2; ctx.stroke(); ctx.fillStyle='#5fc3ff'; ctx.fillRect(s.x-6,s.y-6,12,12);
  }

  // draw batteries
  for (const b of batteries){ const s = worldToScreen(b.lat,b.lng); const latOff = metersToLat(b.range); const edge = worldToScreen(b.lat+latOff, b.lng); const rr = Math.hypot(edge.x-s.x, edge.y-s.y);
    ctx.beginPath(); ctx.arc(s.x,s.y, rr,0,Math.PI*2); ctx.strokeStyle='rgba(36,209,106,0.06)'; ctx.lineWidth=12; ctx.stroke(); ctx.beginPath(); ctx.arc(s.x,s.y, rr,0,Math.PI*2); ctx.strokeStyle='rgba(36,209,106,0.5)'; ctx.lineWidth=2; ctx.stroke(); ctx.fillStyle='#9fe6b8'; ctx.fillRect(s.x-8,s.y-8,16,16);
  }

  // projectiles
  for (const p of projectiles){
    // if target exists get its current pos else show progress along last known vector
    const t = enemies.find(x=>x.id===p.targetId);
    let tx=t? worldToScreen(t.lat,t.lng) : {x:0,y:0};
    const from = worldToScreen(p.fromLat, p.fromLng);
    const pos = {x: from.x + (tx.x - from.x)*p.progress, y: from.y + (tx.y - from.y)*p.progress};
    ctx.beginPath(); ctx.arc(pos.x,pos.y,6,0,Math.PI*2); ctx.fillStyle='rgba(200,240,255,0.95)'; ctx.fill();
  }

  // explosions
  for (const ex of explosions){ const pos = worldToScreen(ex.lat, ex.lng); const t = ex.life/ex.max; ctx.beginPath(); ctx.arc(pos.x,pos.y, ex.size*(1+t), 0, Math.PI*2); ctx.fillStyle = 'rgba(255,140,60,' + (1-t) + ')'; ctx.fill(); }

  // HUD
  ctx.fillStyle='#fff'; ctx.font='13px Arial'; ctx.fillText('En: ' + enemies.length + '  Proj: ' + projectiles.length, 10, 20);
}

function metersToLat(m){ return (m/6371000)*(180/Math.PI); }

// Controls
document.getElementById('startBtn').addEventListener('click', ()=>{ if (!playing){ playing=true; last=performance.now(); update(); addLog('Старт игры'); } paused=false; });
document.getElementById('pauseBtn').addEventListener('click', ()=>{ paused = !paused; addLog(paused? 'Пауза' : 'Возобновлено'); });
document.getElementById('spawnShahed').addEventListener('click', ()=>{ spawn('shahed'); });

// map click to place radar or battery
map.on('click', function(e){ if (e.originalEvent.shiftKey){ // place battery
    batteries.push(createBattery(e.latlng.lat, e.latlng.lng)); document.getElementById('batteryCount').textContent = batteries.length; addLog('Установлена батарея ПВО'); }
  else { radars.push(createRadar(e.latlng.lat, e.latlng.lng)); document.getElementById('radarCount').textContent = radars.length; addLog('Установлена РЛС'); }
});

// Upgrades
function spend(cost){ if (score >= cost){ score -= cost; document.getElementById('score').textContent = score; return true;} addLog('Недостаточно очков'); return false; }

document.getElementById('upgradeDetection').addEventListener('click', ()=>{ if (!spend(100)) return; detectionBonus *= 1.25; addLog('Улучшено обнаружение'); });
document.getElementById('upgradeIntercept').addEventListener('click', ()=>{ if (!spend(150)) return; interceptBonus *= 1.25; addLog('Улучшен шанс перехвата'); });
document.getElementById('buyBattery').addEventListener('click', ()=>{ if (!spend(200)) return; const lat = CITY.lat + (Math.random()-0.5)*0.2; const lng = CITY.lng + (Math.random()-0.5)*0.2; batteries.push(createBattery(lat,lng)); document.getElementById('batteryCount').textContent = batteries.length; addLog('Куплена батарея'); });

// autoEngage wrapper to check every 0.5s
setInterval(()=>{ if (playing && !paused) autoEngage(); }, 500);

// passive score gain
setInterval(()=>{ if (playing && !paused){ score += 1; document.getElementById('score').textContent = score; } }, 1000);

// expose debug
window.__game = {spawn, enemies, radars, batteries};

</script>
</body>
</html>
