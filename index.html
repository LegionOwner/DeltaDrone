<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Advanced Radar — Prototype</title>
  <!-- Leaflet for real map background -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    /* --- Basic layout --- */
    :root{--hud-bg:rgba(0,0,0,0.6);--accent:lime;--muted:#9ee79e}
    html,body,#app{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,monospace;background:#000;color:var(--accent)}
    #map{position:absolute;top:0;left:0;right:0;bottom:0}
    /* overlay canvas sits on top of the map */
    #overlay{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none}

    /* HUD */
    #hud{position:absolute;z-index:700;left:12px;top:12px;background:var(--hud-bg);border:1px solid rgba(0,255,0,0.3);backdrop-filter:blur(4px);padding:10px;border-radius:8px;min-width:240px}
    #hud h1{margin:0 0 6px 0;font-size:16px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    button{background:#000;color:var(--accent);border:1px solid var(--accent);padding:6px 10px;border-radius:6px;cursor:pointer}
    button.primary{background:var(--accent);color:#000}
    #log{max-height:120px;overflow:auto;font-size:12px;color:#9f9}

    /* Control panel bottom for mobile */
    #controls{position:fixed;z-index:800;right:12px;bottom:12px;background:var(--hud-bg);padding:8px;border-radius:8px;border:1px solid rgba(0,255,0,0.2)}
    #controls .big{font-size:18px;padding:8px 12px}

    /* mobile tweaks */
    @media (max-width:600px){
      #hud{left:8px;top:8px;min-width:170px;padding:8px}
      #controls{right:8px;bottom:8px}
      button{padding:8px}
    }

    /* tooltip style */
    .tooltip{position:absolute;background:#000a;color:var(--accent);padding:6px;border-radius:4px;border:1px solid rgba(0,255,0,0.15);font-size:13px;pointer-events:none}
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    <canvas id="overlay"></canvas>

    <div id="hud">
      <h1>Advanced Radar — Prototype</h1>
      <div class="row">
        <button id="startBtn" class="primary">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="clearBtn">Reset</button>
      </div>
      <div style="margin-top:8px" class="row">
        <div id="score">Score: 0</div>
        <div id="time" style="margin-left:8px">Time: 0s</div>
      </div>
      <div style="margin-top:8px">Controls: Click target to fire missile. Long press / touch to guide.</div>
      <div id="log" style="margin-top:8px"></div>
    </div>

    <div id="controls">
      <div class="row">
        <button id="spawnPlane">Spawn Plane</button>
        <button id="spawnDrone">Spawn Drone</button>
        <button id="spawnMissile">Spawn Missile</button>
      </div>
    </div>

    <div id="tooltip" class="tooltip" style="display:none"></div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
  // ------------------- Advanced Radar Prototype -------------------
  // Single-file prototype combining Leaflet map + overlay canvas + game mechanics.
  // Features:
  // - Real map background via Leaflet
  // - Canvas overlay draws radar sweep, targets, trajectories, explosions
  // - Multiple target types (plane/drone/missile) with different behavior
  // - Guided missile firing (click) and simple AI for evasive maneuvers
  // - HUD and logging, mobile touch support
  // - Simple persistence (localStorage) for best score
  
  // --- Setup map ---
  const map = L.map('map', {zoomControl:false}).setView([50.45,30.52], 11); // Kyiv default
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  // Canvas overlay that follows map size
  const overlay = document.getElementById('overlay');
  const ctx = overlay.getContext('2d');

  function resizeCanvas(){
    const rect = document.getElementById('map').getBoundingClientRect();
    overlay.width = rect.width; overlay.height = rect.height; overlay.style.left = rect.left + 'px'; overlay.style.top = rect.top + 'px';
  }
  window.addEventListener('resize',resizeCanvas);
  map.on('move', () => { /* redraw on move */ });
  map.on('zoom', () => { /* redraw on zoom */ resizeCanvas(); });

  // initialize size
  setTimeout(resizeCanvas,100);

  // Convert latlng to overlay pixel coordinates
  function latLngToOverlayPoint(latlng){
    const p = map.latLngToContainerPoint(L.latLng(latlng[0],latlng[1]));
    return {x: p.x, y: p.y};
  }

  // Game state
  let running=false, paused=false;
  let entities = []; // targets, missiles, explosions
  let score=0, startTime=0, elapsed=0;
  let spawnTimer = null;
  const LOG = document.getElementById('log');

  // Settings
  const SETTINGS = {
    spawnInterval: 1800,
    radarRadiusMeters: 15000,
    missileSpeed: 900, // m/s (for simulation scale)
    difficulty: 1
  };

  // Utility: random in range
  function rnd(a,b){return a + Math.random()*(b-a)}

  // --- Entity factory functions ---
  function createTarget(type, latlng, heading, speed){
    return {id: crypto.randomUUID(), kind:'target', type, latlng:[latlng[0],latlng[1]], heading, speed, hp: type==='plane'?3:(type==='drone'?1:1), created:Date.now()};
  }

  function createMissile(fromLatLng, targetEntity){
    return {id:crypto.randomUUID(), kind:'missile', latlng:[fromLatLng[0],fromLatLng[1]], targetId: targetEntity.id, speed: SETTINGS.missileSpeed, life: 20, created:Date.now(), seeker:true};
  }

  function createExplosion(latlng){ return {id:crypto.randomUUID(), kind:'explosion', latlng:[latlng[0],latlng[1]], t:0}; }

  // Spawn helpers: pick random point around center
  function randomPointAround(center, maxMeters){
    const angle = Math.random()*Math.PI*2;
    const dist = Math.random()*maxMeters;
    // approximate conversion meters -> degrees (valid for small distances)
    const dx = (dist/111320) * Math.cos(angle);
    const dy = (dist/111320) * Math.sin(angle) / Math.cos(center[0]*Math.PI/180);
    return [center[0]+dy, center[1]+dx];
  }

  // Spawn routine: create different types
  function spawnRandom(){
    const center = map.getCenter();
    const chance = Math.random();
    if (chance < 0.5){ // plane
      const p = randomPointAround([center.lat, center.lng], 30000);
      entities.push(createTarget('plane', p, rnd(0,360), rnd(120,220)*SETTINGS.difficulty));
    } else if (chance < 0.85){ // missile (incoming)
      const p = randomPointAround([center.lat, center.lng], 45000);
      entities.push(createTarget('missile', p, rnd(0,360), rnd(400,900)*SETTINGS.difficulty));
    } else { // drone
      const p = randomPointAround([center.lat, center.lng], 20000);
      entities.push(createTarget('drone', p, rnd(0,360), rnd(30,80)*SETTINGS.difficulty));
    }
  }

  // Logging utility
  function log(msg){const el = document.getElementById('log'); el.innerHTML = new Date().toLocaleTimeString() + ' — ' + msg + '\n' + el.innerHTML;}

  // Find entity by id
  function byId(id){return entities.find(e=>e.id===id)}

  // Simulation tick (approximate physics in lat/lng space)
  function tick(dt){
    // dt in seconds
    // update targets
    for (let e of entities.slice()){
      if (e.kind==='target'){
        // move by heading & speed (m/s) -> convert to degrees delta
        const meters = e.speed * dt;
        const ang = e.heading * Math.PI/180;
        const dx = meters * Math.cos(ang);
        const dy = meters * Math.sin(ang);
        const dlon = dx/111320;
        const dlat = (dy/111320) * (1/Math.cos(e.latlng[0]*Math.PI/180));
        e.latlng[0] += dlat; e.latlng[1] += dlon;

        // small AI: drones can change heading randomly
        if (e.type==='drone' && Math.random() < 0.02) e.heading += rnd(-40,40);

        // if plane/missile passes near center, count as 'hit city' and remove
        const center = [map.getCenter().lat, map.getCenter().lng];
        const px = haversine(e.latlng, center);
        if (px < 500 && e.type!=='plane'){
          log('⚠️: ' + e.type + ' reached defended zone');
          entities = entities.filter(x => x.id !== e.id);
        }
      }
      else if (e.kind==='missile'){
        // homing missile: steer toward target
        const tgt = byId(e.targetId);
        if (!tgt){ e.life = -1; continue; }
        // compute vector to target
        const dx = (tgt.latlng[1] - e.latlng[1]);
        const dy = (tgt.latlng[0] - e.latlng[0]);
        const distMeters = haversine(tgt.latlng, e.latlng);
        if (distMeters < 200){
          // explosion
          entities.push(createExplosion(tgt.latlng));
          log('💥 Target hit!');
          score += 10;
          document.getElementById('score').innerText = 'Score: ' + score;
          // damage target
          tgt.hp -= 1; if (tgt.hp <= 0) entities = entities.filter(x=>x.id!==tgt.id);
          e.life = -1; // missile consumed
        } else {
          // move missile a small step toward target using meters->deg
          const speed = e.speed; // m/s
          const step = Math.min(speed*dt, distMeters);
          const heading = Math.atan2(dx, dy); // note swapped axis
          const moveX = step * Math.sin(heading); // longitude
          const moveY = step * Math.cos(heading); // latitude
          e.latlng[1] += moveX/111320;
          e.latlng[0] += (moveY/111320) * (1/Math.cos(e.latlng[0]*Math.PI/180));
          e.life -= dt;
          if (e.life <= 0) e.life = -1;
        }
      }
      else if (e.kind==='explosion'){
        e.t += dt;
        if (e.t > 2) entities = entities.filter(x=>x.id!==e.id);
      }
    }
    // remove dead missiles
    entities = entities.filter(e=>!(e.kind==='missile' && e.life<=0));
  }

  // --- Rendering ---
  let sweepAngle = 0;
  function render(){
    ctx.clearRect(0,0,overlay.width,overlay.height);

    // radar sweep
    const centerLatLng = [map.getCenter().lat, map.getCenter().lng];
    const centerPt = latLngToOverlayPoint([centerLatLng[0], centerLatLng[1]]);

    // draw concentric detection rings (meters -> pixels approximate via lat->px conversion)
    const ringMeters = [5000, 15000, 30000];
    ctx.save();
    ctx.globalAlpha = 0.25;
    for (let r=0;r<ringMeters.length;r++){
      const latShift = centerLatLng[0] + (ringMeters[r]/111320);
      const p = latLngToOverlayPoint([latShift, centerLatLng[1]]);
      const radius = Math.abs(p.y - centerPt.y);
      ctx.strokeStyle = ['#0f0','#0ff','#00f'][r];
      ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(centerPt.x, centerPt.y, radius,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();

    // sweep beam
    sweepAngle += 0.8; if (sweepAngle>360) sweepAngle-=360;
    ctx.save(); ctx.translate(centerPt.x, centerPt.y);
    ctx.beginPath();
    const a = (sweepAngle-6) * Math.PI/180; const b = (sweepAngle+6) * Math.PI/180;
    const maxR = Math.max(overlay.width, overlay.height)*1.5;
    ctx.moveTo(0,0); ctx.arc(0,0, maxR, -a, -b, true);
    ctx.closePath(); ctx.fillStyle = 'rgba(0,255,0,0.06)'; ctx.fill();
    ctx.restore();

    // draw entities
    for (let e of entities){
      if (e.kind==='target'){
        const p = latLngToOverlayPoint(e.latlng);
        // if offscreen skip
        if (p.x< -50 || p.x>overlay.width+50 || p.y< -50 || p.y>overlay.height+50) continue;
        // draw icon
        ctx.save();
        if (e.type==='plane'){
          ctx.fillStyle='rgba(255,200,0,0.9)'; ctx.beginPath(); ctx.ellipse(p.x,p.y,10,6, e.heading*Math.PI/180,0,Math.PI*2); ctx.fill();
        } else if (e.type==='drone'){
          ctx.fillStyle='rgba(255,0,100,0.9)'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
        } else if (e.type==='missile'){
          ctx.fillStyle='rgba(255,50,50,0.95)'; ctx.beginPath(); ctx.moveTo(p.x,p.y-6); ctx.lineTo(p.x+4,p.y+6); ctx.lineTo(p.x-4,p.y+6); ctx.closePath(); ctx.fill();
        }
        ctx.restore();

        // draw label
        ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(p.x+8,p.y-10,60,18);
        ctx.fillStyle= '#9f9'; ctx.font='12px monospace'; ctx.fillText(e.type + ' | ' + Math.round(e.speed) + 'm/s', p.x+10, p.y+4);
      }
      else if (e.kind==='missile'){
        const p = latLngToOverlayPoint(e.latlng);
        ctx.fillStyle='rgba(255,255,120,0.95)'; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
      }
      else if (e.kind==='explosion'){
        const p = latLngToOverlayPoint(e.latlng);
        const t = e.t; const r = 30 * t;
        ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2);
        ctx.fillStyle = `rgba(255,120,0,${Math.max(0,0.6 - t*0.3)})`; ctx.fill();
      }
    }

    // draw simple crosshair at center
    ctx.strokeStyle='rgba(0,255,0,0.3)'; ctx.beginPath(); ctx.moveTo(centerPt.x-10,centerPt.y); ctx.lineTo(centerPt.x+10,centerPt.y); ctx.moveTo(centerPt.x,centerPt.y-10); ctx.lineTo(centerPt.x,centerPt.y+10); ctx.stroke();

    // HUD overlay additional
  }

  // --- Basic physics helpers ---
  // Haversine: approximate distance in meters between two [lat,lng]
  function haversine(a,b){
    const R = 6371000; const lat1=a[0]*Math.PI/180; const lat2=b[0]*Math.PI/180;
    const dLat = (b[0]-a[0])*Math.PI/180; const dLon = (b[1]-a[1])*Math.PI/180;
    const aa = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2);
    const c = 2*Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa)); return R*c;
  }

  // --- Input handling: click -> fire missile to nearest target within range ---
  function handleClickClient(x,y){
    // convert pixel to latlng
    const containerPoint = L.point(x,y);
    const latlng = map.containerPointToLatLng(containerPoint);
    // find closest target within 60000m
    let candidates = entities.filter(e=>e.kind==='target');
    let min=null; let distMin=Infinity;
    for (let c of candidates){ const d = haversine([latlng.lat,latlng.lng], c.latlng); if (d < distMin){distMin=d; min=c} }
    if (min && distMin < 60000){
      // spawn missile from center
      const center = [map.getCenter().lat, map.getCenter().lng];
      entities.push(createMissile(center, min));
      log('🚀 Missile launched at ' + min.type + ' (' + Math.round(distMin) + 'm)');
    } else log('— No valid target in range');
  }

  // touch support: tap to fire; long press to show tooltip
  overlay.addEventListener('click', (ev)=>{
    const rect = overlay.getBoundingClientRect(); handleClickClient(ev.clientX - rect.left, ev.clientY - rect.top);
  });

  // buttons
  document.getElementById('startBtn').addEventListener('click', ()=>{
    if (running) return; running=true; paused=false; score=0; startTime=Date.now();
    document.getElementById('score').innerText='Score: 0'; document.getElementById('time').innerText='Time: 0s';
    // start spawn
    spawnTimer = setInterval(()=>{ spawnRandom(); }, SETTINGS.spawnInterval);
    log('▶️ Simulation started');
  });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ paused=!paused; document.getElementById('pauseBtn').innerText = paused? 'Resume' : 'Pause'; });
  document.getElementById('clearBtn').addEventListener('click', ()=>{ running=false; clearInterval(spawnTimer); spawnTimer=null; entities=[]; log('🔄 Reset'); });

  document.getElementById('spawnPlane').addEventListener('click', ()=>{ entities.push(createTarget('plane', randomPointAround([map.getCenter().lat,map.getCenter().lng],15000), rnd(0,360), rnd(120,220))); });
  document.getElementById('spawnDrone').addEventListener('click', ()=>{ entities.push(createTarget('drone', randomPointAround([map.getCenter().lat,map.getCenter().lng],9000), rnd(0,360), rnd(30,80))); });
  document.getElementById('spawnMissile').addEventListener('click', ()=>{ entities.push(createTarget('missile', randomPointAround([map.getCenter().lat,map.getCenter().lng],35000), rnd(0,360), rnd(400,900))); });

  // Main loop
  let last = performance.now();
  function mainLoop(now){
    const dt = (now - last)/1000; last = now;
    if (running && !paused){
      tick(dt);
      elapsed = Math.floor((Date.now() - startTime)/1000);
      document.getElementById('time').innerText = 'Time: ' + elapsed + 's';
    }
    render();
    requestAnimationFrame(mainLoop);
  }
  requestAnimationFrame(mainLoop);

  // initial demo entities
  entities.push(createTarget('plane', [50.6,30.4], 180, 160));
  entities.push(createTarget('drone', [50.5,30.7], 90, 40));
  entities.push(createTarget('missile', [50.7,30.2], 230, 500));

  // helpful tip log
  log('Ready. Click on the map to fire guided missile from center.');

  </script>
</body>
</html>

